# Dual ROI Line Tracer

학습 없이 좌우 하단 ROI를 사용한 라인 트레이싱 시스템

## 특징

- **학습 불필요**: 딥러닝 모델 없이 OpenCV만 사용
- **Dual ROI**: 좌우 하단 영역을 독립적으로 감지
- **적응형 제어**: 라인이 사라진 쪽으로 회전하여 라인 복귀
- **실시간 튜닝**: 파라미터를 실시간으로 조정 가능

## 동작 원리

### 1. ROI 설정
- 화면 하단을 좌측과 우측 두 개의 ROI로 분할
- 각 ROI에서 독립적으로 라인 감지

### 2. 라인 감지
- 그레이스케일 변환 → 가우시안 블러 → 이진화
- 흰색 픽셀 수를 카운트하여 라인 존재 여부 판단

### 3. 제어 로직
```
좌우 모두 라인 있음 → 직진
좌측만 라인 없음   → 좌회전 (라인 복귀)
우측만 라인 없음   → 우회전 (라인 복귀)
좌우 모두 라인 없음 → 정지
```

## 설치 및 실행

### 필요 라이브러리
```bash
pip install opencv-python numpy
```

Raspberry Pi에서 실제 모터 제어 시:
```bash
pip install RPi.GPIO
```

### 실행
```bash
python dual_roi_line_tracer.py
```

### GPIO 모드 활성화
코드 상단에서 `USE_GPIO = True`로 변경

## 키보드 조작

| 키 | 기능 |
|---|---|
| q / ESC | 프로그램 종료 |
| 1 / 2 | 이진화 임계값 조정 (어둡게/밝게) |
| 3 / 4 | ROI 높이 조정 (증가/감소) |
| 5 / 6 | ROI 너비 조정 (증가/감소) |
| 7 / 8 | 최소 픽셀 수 조정 (증가/감소) |

## 파라미터 튜닝 가이드

### 1. 이진화 임계값 (thresh)
- **기본값**: 150
- **조정**: 키 1(감소) / 2(증가)
- **효과**:
  - 값이 낮을수록 더 어두운 선도 감지
  - 값이 높을수록 밝은 선만 감지

### 2. ROI 높이 비율 (roi_height_ratio)
- **기본값**: 0.3 (화면 하단 30%)
- **조정**: 키 3(증가) / 4(감소)
- **효과**:
  - 값이 클수록 더 넓은 영역 감지
  - 값이 작을수록 좁은 영역만 감지

### 3. ROI 너비 비율 (roi_width_ratio)
- **기본값**: 0.3 (화면 좌우 각 30%)
- **조정**: 키 5(증가) / 6(감소)
- **효과**:
  - 값이 클수록 화면 중앙에 가까운 영역 감지
  - 값이 작을수록 화면 가장자리만 감지

### 4. 최소 픽셀 수 (min_pixels)
- **기본값**: 100 픽셀
- **조정**: 키 7(증가) / 8(감소)
- **효과**:
  - 값이 클수록 더 굵은 선만 감지 (노이즈 감소)
  - 값이 작을수록 가는 선도 감지 (민감도 증가)

## 디버그 화면 설명

### 메인 화면 (Line Tracer)
- **녹색 박스**: 라인이 감지된 ROI
- **빨간색 박스**: 라인이 없는 ROI
- **텍스트**: 현재 명령과 픽셀 수 표시

### Left/Right ROI 창
- 이진화된 좌우 ROI 이미지
- 흰색 영역이 감지된 라인

## 튜닝 예시

### 검은색 선 트레이싱
```python
thresh = 150  # 기본값 사용
# 화면이 밝으면 thresh를 높이고, 어두우면 낮춤
```

### 흰색 선 트레이싱
코드 수정 필요 (THRESH_BINARY 사용):
```python
_, binary = cv2.threshold(blur, thresh, 255, cv2.THRESH_BINARY)
```

### 좁은 트랙
```python
roi_width_ratio = 0.2  # ROI 너비 감소
```

### 넓은 트랙
```python
roi_width_ratio = 0.4  # ROI 너비 증가
```

## 트러블슈팅

### 문제: 라인을 감지하지 못함
**해결책**:
1. 키 1을 눌러 임계값을 낮춤
2. 키 7을 눌러 최소 픽셀 수를 낮춤
3. 조명 환경 개선

### 문제: 너무 민감하게 반응
**해결책**:
1. 키 2를 눌러 임계값을 높임
2. 키 8을 눌러 최소 픽셀 수를 높임
3. ROI 크기 조정

### 문제: 회전이 과도함
**해결책**:
1. `motor_left()`, `motor_right()` 함수의 speed 값을 낮춤
2. ROI 너비를 조정하여 감지 영역 변경

## 성능 최적화

### 해상도 조정
카메라 해상도를 낮추면 처리 속도 향상:
```python
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
```

### ROI 크기 최적화
ROI를 너무 크게 하면 불필요한 연산 증가

## 향후 개선 가능 사항

1. **PID 제어**: 부드러운 주행을 위한 PID 컨트롤러 추가
2. **속도 조절**: 직선에서는 빠르게, 커브에서는 느리게
3. **히스토리 기반 제어**: 이전 상태를 기억하여 더 안정적인 제어
4. **적응형 임계값**: 조명 변화에 자동으로 대응

## 기술 스택

- Python 3.x
- OpenCV
- NumPy
- RPi.GPIO (Raspberry Pi에서만)

## 라이선스

MIT License

## 문의

버그 리포트나 개선 제안은 이슈로 등록해주세요.
